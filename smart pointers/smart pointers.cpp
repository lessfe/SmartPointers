#include <iostream>
using namespace std;

/*
		Умный указатель.
	Будет сам очищать память после выделения.
*/

// Шаблонный тип данных нужен для класса умного указателя, т.к. изначально мы не знаем с данными какого типа мы будет работать.
template<typename T> 

class SmartPointer
{


public:
	// Конструктор принмиает указатель шаблонного типа и присваивает нашему указателю тот, который он получил.
	SmartPointer(T* ptr) { this->ptr = ptr;}; // (*this).ptr
	~SmartPointer() { delete ptr; };

	T& operator*() { return *ptr; } /*	Мы должны возращать ссылку на наш шаблонный тип данных, т.к. если мы вернем просто T, то у нас создастся копия того объекта, который находится в динамической памяти,
	 и получим мы его копию.
	 Далее вызываем перегруженный оператор разыменования и в теле функции возращаем разыменованный указатель.
	 */
private:
	T* ptr;
};


int main()
{
	// Так как класс шаблонный, то необходимо указать его тип. 
	
	SmartPointer<int> pointer = new int(5);
	// Так как класс возращает ссылку на существующий объект, то мы можем делать и следующее:
	*pointer = 12534;
	cout << *pointer;
}

